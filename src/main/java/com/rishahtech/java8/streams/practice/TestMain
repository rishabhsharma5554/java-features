package com.app.bank.bank_demo;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TestMain {
    static void main() {
        ArrayList<Employee> employeeList = new ArrayList<>();
        employeeList.add(new Employee(111, "Jiya Brein", 32, "Female", "HR", 2011, 25000.0));
        employeeList.add(new Employee(122, "Paul Niksui", 25, "Male", "Sales And Marketing", 2015, 13500.0));
        employeeList.add(new Employee(133, "Martin Theron", 29, "Male", "Infrastructure", 2012, 18000.0));
        employeeList.add(new Employee(144, "Murali Gowda", 28, "Male", "Product Development", 2014, 32500.0));
        employeeList.add(new Employee(155, "Nima Roy", 27, "Female", "HR", 2013, 22700.0));
        employeeList.add(new Employee(166, "Iqbal Hussain", 75, "Male", "Security And Transport", 2016, 10500.0));
        employeeList.add(new Employee(177, "Manu Sharma", 35, "Male", "Account And Finance", 2010, 27000.0));
        employeeList.add(new Employee(188, "Wang Liu", 31, "Male", "Product Development", 2015, 34500.0));
        employeeList.add(new Employee(199, "Amelia Zoe", 24, "Female", "Sales And Marketing", 2016, 11500.0));
        employeeList.add(new Employee(200, "Jaden Dough", 38, "Male", "Security And Transport", 2015, 11000.5));
        employeeList.add(new Employee(211, "Jasna Kaur", 27, "Female", "Infrastructure", 2014, 15700.0));
        employeeList.add(new Employee(222, "Nitin Joshi", 25, "Male", "Product Development", 2016, 28200.0));
        employeeList.add(new Employee(233, "Jyothi Reddy", 27, "Female", "Account And Finance", 2013, 21300.0));
        employeeList.add(new Employee(244, "Nicolus Den", 24, "Male", "Sales And Marketing", 2017, 10700.5));
        employeeList.add(new Employee(255, "Ali Baig", 23, "Male", "Infrastructure", 2018, 12700.0));
        employeeList.add(new Employee(266, "Sanvi Pandey", 26, "Female", "Product Development", 2015, 28900.0));
        employeeList.add(new Employee(277, "Anuj Chettiar", 31, "Male", "Product Development", 2012, 35700.0));
		employeeList.forEach(System.out::println);

        //key points
        /*
         filter :
            To filter the stream based on a condition
            uses a PREDICATE (a function that returns a boolean)

         map :
            To transform each element of the stream into another form
            Uses a FUNCTION (a function that takes an input and produces an output)

         collect :
            To gather the stream elements into a collection or a summary result
            uses a COLLECTOR (a function that defines how to accumulate the stream elements into a result container)
            Result in can be a List, Set, Map, or a single value (like count, average, etc.)

         groupingBy :
            To group the stream elements based on a classifier function and a downstream collector (optional)
            uses a CLASSIFIER FUNCTION (a function that takes an element and returns a key for grouping) and a DOWNSTREAM COLLECTOR (a collector that defines how to collect the grouped elements)
            Result in a Map where the keys are the group identifiers and the values are the collected results for each group

         collect with groupingBy:
            Result in a Map where the keys are the group identifiers and the values are the collected results for each group

         counting : to count the number of elements in a group
         averagingDouble : to calculate the average of a numeric property in a group
        */

        System.out.println("\n*********************Query 1 : How many male and female employees are there in the organization? Provide only count");
        Long maleCount = employeeList.stream().filter(e -> e.getGender().equalsIgnoreCase("Male")).count();
        System.out.println("Number of male employees : " + maleCount);
        Long femaleCount = employeeList.stream().filter(femaleEmp -> femaleEmp.getGender().equalsIgnoreCase("female")).count();
        System.out.println("Number of female employees : " + femaleCount);

        System.out.println("\n*********************Query 2 : How many male and female employees are there in the organization? In a Single line of code");
        Map<String, Long> employeeCount = employeeList.stream().collect(Collectors.groupingBy(Employee::getGender,Collectors.counting()));
        System.out.println("Total Count of Employees by gender in the organization : " + employeeCount);

        System.out.println("\n*********************Query 3 : Print the name of all departments in the organization?");
        List<String> list = employeeList.stream().map(Employee::getDepartment).distinct().toList();
        System.out.println("Name of all departments in the organization : " + list);

        System.out.println("\n*********************Query 4 : What is the average age of male and female employees?");
        Map<String, Double> averageMaleAndFemale =   employeeList.stream().collect(Collectors.groupingBy(Employee::getGender,Collectors.averagingDouble(Employee::getAge)));
        System.out.println(averageMaleAndFemale);

        System.out.println("\n*********************Query 5 : Get the details of highest paid employee in the organization?");
        Employee maxEmpSalary = employeeList.stream().collect(Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))).get();
        System.out.println(maxEmpSalary);
        Employee empWithMaxSalary = employeeList.stream().max(Comparator.comparingDouble(Employee::getSalary)).orElseThrow();
        System.out.println(empWithMaxSalary);

        System.out.println("\n*********************Query 6 : Get the names of all employees who have joined after 2015?");
        employeeList.stream().filter(emp -> emp.getYearOfJoining() > 2015).map(emp -> emp.getName()).forEach(System.out::println);
        employeeList.stream().filter(emp -> emp.getYearOfJoining() > 2015).map(Employee::getName).forEach(System.out::println);

        System.out.println("\n*********************Query 7 : Count the number of employees in each department?");
        Map<String,Long> depCount =  employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment,Collectors.counting()));
        System.out.println(depCount);

        System.out.println("\n*********************Query 8 : What is the average salary of each department?");
        Map<String, Double> collect = employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment, Collectors.averagingDouble(Employee::getSalary)));
        System.out.println(collect);

        System.out.println("\n*********************Query 9 : Get the details of youngest male employee in the product development department?");
        employeeList.stream().filter(emp -> emp.getGender().equalsIgnoreCase("Male")).sorted(Comparator.comparingInt(Employee::getAge)).filter(emp -> emp.getDepartment().equalsIgnoreCase("Product Development")).findFirst().ifPresent(System.out::println);
        employeeList.stream().filter(e -> e.getDepartment().equalsIgnoreCase("Product Development") && e.getGender().equalsIgnoreCase("Male")).sorted(Comparator.comparingInt(Employee::getAge)).findFirst().ifPresent(System.out::println);

        System.out.println("\n*********************Query 10 : Who has the most working experience in the organization?");
        employeeList.stream().sorted(Comparator.comparingInt(Employee::getYearOfJoining)).findFirst().ifPresent(System.out::println);
        employeeList.stream().sorted(Comparator.comparingInt(Employee::getYearOfJoining)).findFirst().map(Employee::getName).ifPresent(System.out::println);

        System.out.println("\n*********************Query 11 : How many male and female employees are there in the sales?");
        Map<String, Long> salesAndMarketing = employeeList.stream().filter(e -> e.getDepartment().equalsIgnoreCase("Sales And Marketing")).collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));
        System.out.println(salesAndMarketing);

        System.out.println("\n*********************Query 12 : What is the average salary of male and female employees?");
        Map<String,Double> avgSalByGender = employeeList.stream().collect(Collectors.groupingBy(Employee::getGender,Collectors.averagingDouble(Employee::getSalary)));
        System.out.println(avgSalByGender);

        System.out.println("\n*********************Query 13 : List down the names of all employees in each department?");
        Map<String,List<Employee>> empByDep =  employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment));
//        for(Map.Entry<String,List<Employee>> map : empByDep.entrySet())
//        {
//            System.out.println(map.getKey()+" "+map.getValue());
//        }
        System.out.println(empByDep);

        System.out.println("\n*********************Query 14 : What is the average salary and total salary of the whole organization?");
        Double avgSalary  = employeeList.stream().collect(Collectors.summarizingDouble(Employee::getSalary)).getAverage();
        Double totalSalary = employeeList.stream().collect(Collectors.summarizingDouble(Employee::getSalary)).getSum();
        System.out.println("Average Salary of the whole organization : " + totalSalary);
        System.out.println("Total Salary of the whole organization : " + avgSalary);

        Double avgSalary2 = employeeList.stream().collect(Collectors.averagingDouble(Employee::getSalary));
        System.out.println("Total Salary of the whole organization : " + avgSalary2);

        System.out.println("\n*********************Query 15 : Separate the employees who are younger or equal to 25 years from those employees who are older than 25 years.");
        employeeList.stream().collect(Collectors.partitioningBy(emp -> emp.getAge() <= 25)).forEach((isYoung, empList) -> {
            System.out.println(isYoung ? "Employees younger or equal to 25 years :" : "Employees older than 25 years :");
            empList.forEach(System.out::println);
        });

        Map<Boolean, List<Employee>> trueFalseGroup =  employeeList.stream().collect(Collectors.partitioningBy(emp -> emp.getAge() <= 25));
        for(Map.Entry<Boolean,List<Employee>> map: trueFalseGroup.entrySet())
        {
            System.out.println(map.getKey());
            map.getValue().forEach(System.out::println);
        }

        System.out.println("\n*********************Query 16 : Who is the oldest employee in the organization? What is his age and which department he belongs to?");
        employeeList.stream().sorted(Comparator.comparingInt(Employee::getAge).reversed()).findFirst().ifPresent(System.out::println);
        employeeList.stream().max(Comparator.comparingInt(Employee::getAge)).ifPresent(System.out::println);

        System.out.println("\n*********************Query 17 : get all the females in the sales department and print their names?");
        employeeList.stream().filter(emp -> emp.getDepartment().equalsIgnoreCase("Sales And Marketing") && emp.getGender().equalsIgnoreCase("female")).map(emp->emp.getName()).forEach(System.out::println);

        System.out.println("\n*********************Query 18 : Print the Max Salary Employees from each Deaprtment? ");
        Map<String, Optional<Employee>> maxSalaryByDep = employeeList.stream().collect(Collectors.groupingBy(Employee::getDepartment, Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));
        System.out.println(maxSalaryByDep);

        System.out.println("\n*********************Query 19 : Find 2nd highest salary in the organization?");
        employeeList.stream().max(Comparator.comparingDouble(Employee::getSalary)).ifPresent(System.out::println);
//        employeeList.stream().filter(emp5 -> emp5.getSalary() < emp5.getSalary()).max(Comparator.comparingDouble(Employee::getSalary)).ifPresent(System.out::println);
        // Easier approach: sort descending, skip 1st, pick next
        employeeList.stream().sorted(Comparator.comparingDouble(Employee::getSalary).reversed()).skip(1).findFirst().ifPresent(System.out::println);


        System.out.println("\n*********************Query 20 : Find 2nd highest salary in the female employees in organization?");
        List<String> female = employeeList.stream().filter(emp -> emp.getGender().equalsIgnoreCase("female")).sorted(Comparator.comparingDouble(Employee::getSalary)).map(Employee::getName).toList();
        System.out.println(female);
        employeeList.stream().filter(emp -> emp.getGender().equalsIgnoreCase("female")).sorted(Comparator.comparingDouble(Employee::getSalary).reversed()).skip(1).findFirst().ifPresent(System.out::println);

        // ========================= flatMap Questions =========================

        System.out.println("\n*********************FlatMap Q1 : Split all employee names into individual words and collect as a flat list?");
        List<String> allNameWords = employeeList.stream()
                .map(Employee::getName)
                .flatMap(name -> Arrays.stream(name.split(" ")))
                .toList();
        System.out.println("All name words : " + allNameWords);

        System.out.println("\n*********************FlatMap Q2 : Get all distinct words from department names?");
        List<String> distinctDeptWords = employeeList.stream()
                .map(Employee::getDepartment)
                .flatMap(dept -> Arrays.stream(dept.split(" And | ")))
                .distinct()
                .toList();
        System.out.println("Distinct department words : " + distinctDeptWords);

        System.out.println("\n*********************FlatMap Q3 : Get all distinct characters from all employee names (lowercase)?");
        List<String> distinctChars = employeeList.stream()
                .map(Employee::getName)
                .flatMap(name -> Arrays.stream(name.toLowerCase().split("")))
                .filter(ch -> !ch.equals(" "))
                .distinct()
                .sorted()
                .toList();
        System.out.println("Distinct characters in employee names : " + distinctChars);

        System.out.println("\n*********************FlatMap Q4 : For each department, get a flat list of (department - employeeName) strings?");
        List<String> deptEmpPairs = employeeList.stream()
                .collect(Collectors.groupingBy(Employee::getDepartment))
                .entrySet().stream()
                .flatMap(entry -> entry.getValue().stream()
                        .map(emp -> entry.getKey() + " - " + emp.getName()))
                .toList();
        System.out.println("Department-Employee pairs : ");
        deptEmpPairs.forEach(System.out::println);

        System.out.println("\n*********************FlatMap Q5 : Given a list of lists of employees (grouped by gender), flatten into a single list sorted by salary?");
        List<List<Employee>> groupedByGender = new ArrayList<>(employeeList.stream()
                .collect(Collectors.groupingBy(Employee::getGender))
                .values());
        List<String> flattenedSorted = groupedByGender.stream()
                .flatMap(List::stream)
                .sorted((e1, e2) -> Double.compare(e2.getSalary(), e1.getSalary()))
                .map(e -> e.getName() + " -> " + e.getSalary())
                .toList();
        System.out.println("Flattened & sorted by salary (desc) : ");
        flattenedSorted.forEach(System.out::println);

        System.out.println("\n*********************FlatMap Q6 : For each employee, generate multiple attributes as a flat stream (name, department, salary) and collect?");
        List<String> empAttributes = employeeList.stream()
                .flatMap(e -> Stream.of(
                        "Name: " + e.getName(),
                        "Dept: " + e.getDepartment(),
                        "Salary: " + e.getSalary()))
                .toList();
        System.out.println("Employee attributes (first 9) : ");
        empAttributes.stream().limit(9).forEach(System.out::println);

        System.out.println("\n*********************FlatMap Q7 : Get employees whose name contains more than one word and collect all first names?");
        List<String> firstNames = employeeList.stream()
                .map(Employee::getName)
                .filter(name -> name.split(" ").length > 1)
                .flatMap(name -> Stream.of(name.split(" ")[0]))
                .distinct()
                .toList();
        System.out.println("First names of multi-word named employees : " + firstNames);

        *********************FlatMap Q1 : Split all employee names into individual words and collect as a flat list?
All name words : [Jiya, Brein, Paul, Niksui, Martin, Theron, Murali, Gowda, Nima, Roy, Iqbal, Hussain, Manu, Sharma, Wang, Liu, Amelia, Zoe, Jaden, Dough, Jasna, Kaur, Nitin, Joshi, Jyothi, Reddy, Nicolus, Den, Ali, Baig, Sanvi, Pandey, Anuj, Chettiar]

*********************FlatMap Q2 : Get all distinct words from department names?
Distinct department words : [HR, Sales, Marketing, Infrastructure, Product, Development, Security, Transport, Account, Finance]

*********************FlatMap Q3 : Get all distinct characters from all employee names (lowercase)?
Distinct characters in employee names : [a, b, c, d, e, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, y, z]

*********************FlatMap Q4 : For each department, get a flat list of (department - employeeName) strings?
Department-Employee pairs : 
Product Development - Murali Gowda
Product Development - Wang Liu
Product Development - Nitin Joshi
Product Development - Sanvi Pandey
Product Development - Anuj Chettiar
Security And Transport - Iqbal Hussain
Security And Transport - Jaden Dough
Sales And Marketing - Paul Niksui
Sales And Marketing - Amelia Zoe
Sales And Marketing - Nicolus Den
Infrastructure - Martin Theron
Infrastructure - Jasna Kaur
Infrastructure - Ali Baig
HR - Jiya Brein
HR - Nima Roy
Account And Finance - Manu Sharma
Account And Finance - Jyothi Reddy

*********************FlatMap Q5 : Given a list of lists of employees (grouped by gender), flatten into a single list sorted by salary?
Flattened & sorted by salary (desc) : 
Anuj Chettiar -> 35700.0
Wang Liu -> 34500.0
Murali Gowda -> 32500.0
Sanvi Pandey -> 28900.0
Nitin Joshi -> 28200.0
Manu Sharma -> 27000.0
Jiya Brein -> 25000.0
Nima Roy -> 22700.0
Jyothi Reddy -> 21300.0
Martin Theron -> 18000.0
Jasna Kaur -> 15700.0
Paul Niksui -> 13500.0
Ali Baig -> 12700.0
Amelia Zoe -> 11500.0
Jaden Dough -> 11000.5
Nicolus Den -> 10700.5
Iqbal Hussain -> 10500.0

*********************FlatMap Q6 : For each employee, generate multiple attributes as a flat stream (name, department, salary) and collect?
Employee attributes (first 9) : 
Name: Jiya Brein
Dept: HR
Salary: 25000.0
Name: Paul Niksui
Dept: Sales And Marketing
Salary: 13500.0
Name: Martin Theron
Dept: Infrastructure
Salary: 18000.0

*********************FlatMap Q7 : Get employees whose name contains more than one word and collect all first names?
First names of multi-word named employees : [Jiya, Paul, Martin, Murali, Nima, Iqbal, Manu, Wang, Amelia, Jaden, Jasna, Nitin, Jyothi, Nicolus, Ali, Sanvi, Anuj]


    }
}
